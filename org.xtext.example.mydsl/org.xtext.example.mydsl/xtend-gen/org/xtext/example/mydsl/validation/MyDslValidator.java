/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.mydsl.myDsl.Class_declaration;
import org.xtext.example.mydsl.myDsl.Field_declaration;
import org.xtext.example.mydsl.myDsl.Interface_declaration;
import org.xtext.example.mydsl.myDsl.Method_declaration;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Type_declaration;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  public Map<String, List<String>> classeExtends = new HashMap<String, List<String>>();
  
  @Check
  public Object validaTypeDeclaration(final Type_declaration td) {
    Object _xifexpression = null;
    Class_declaration _classDec = td.getClassDec();
    if ((_classDec instanceof Class_declaration)) {
      Object _xblockexpression = null;
      {
        Class_declaration _classDec_1 = td.getClassDec();
        Class_declaration cd = ((Class_declaration) _classDec_1);
        _xblockexpression = this.validaClass(cd);
      }
      _xifexpression = _xblockexpression;
    } else {
      Interface_declaration _interfaceDec = td.getInterfaceDec();
      Interface_declaration id = ((Interface_declaration) _interfaceDec);
      this.validaInterface(id);
    }
    return _xifexpression;
  }
  
  public void validaInterface(final Interface_declaration declaration) {
    EList<String> _modifiers = declaration.getModifiers();
    this.validaModifiers(_modifiers);
    EList<Field_declaration> _fieldsDeclaration = declaration.getFieldsDeclaration();
    for (final Field_declaration field : _fieldsDeclaration) {
      this.validaFieldDeclaration(field);
    }
  }
  
  public Object validaFieldDeclaration(final Field_declaration declaration) {
    return null;
  }
  
  public Object validaModifiers(final EList<String> list) {
    return null;
  }
  
  public Object validaClass(final Class_declaration declaration) {
    Object _xblockexpression = null;
    {
      EList<String> _modifiers = declaration.getModifiers();
      this.validaModifiers(_modifiers);
      EList<String> interfaces = declaration.getInterfacesImplementadas();
      String _interfaceImplementada = declaration.getInterfaceImplementada();
      interfaces.add(_interfaceImplementada);
      for (final String interfaceName : interfaces) {
        this.validaHerancaInterface(declaration, interfaceName);
      }
      String _classHerdada = declaration.getClassHerdada();
      _xblockexpression = this.validaHerancaClass(_classHerdada);
    }
    return _xblockexpression;
  }
  
  public Object validaHerancaClass(final String string) {
    return null;
  }
  
  public Object validaHerancaInterface(final Class_declaration declaration, final String string) {
    return null;
  }
  
  @Check
  public void checkMethodDeclaration(final Method_declaration md) {
    EList<String> methodMods = md.getModifiersMethod();
    int a = 0;
    for (final String mod : methodMods) {
      boolean _and = false;
      if (!(a == 0)) {
        _and = false;
      } else {
        boolean _equals = mod.equals("public");
        _and = _equals;
      }
      if (_and) {
        this.error("Classe name error", md, MyDslPackage.Literals.METHOD_DECLARATION__NAME_METHOD);
      }
    }
  }
}
