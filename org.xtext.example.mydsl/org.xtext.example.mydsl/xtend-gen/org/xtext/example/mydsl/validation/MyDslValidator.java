/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.xtex.example.mydsl.exceptions.MyDslException;
import org.xtext.example.mydsl.myDsl.Class_declaration;
import org.xtext.example.mydsl.myDsl.Constructor_declaration;
import org.xtext.example.mydsl.myDsl.Expression;
import org.xtext.example.mydsl.myDsl.Expression_aux;
import org.xtext.example.mydsl.myDsl.Field_declaration;
import org.xtext.example.mydsl.myDsl.Interface_declaration;
import org.xtext.example.mydsl.myDsl.Logical_Expression_NR;
import org.xtext.example.mydsl.myDsl.Method_declaration;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Statement_block;
import org.xtext.example.mydsl.myDsl.Type_declaration;
import org.xtext.example.mydsl.myDsl.Variable_declaration;
import org.xtext.example.mydsl.myDsl.Variable_declarator;
import org.xtext.example.mydsl.myDsl.While_Statement;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;
import org.xtext.example.mydsl.validation.utils.Classes;
import org.xtext.example.mydsl.validation.utils.ConstructorObj;
import org.xtext.example.mydsl.validation.utils.ContructorValidate;
import org.xtext.example.mydsl.validation.utils.ExpressionValidate;
import org.xtext.example.mydsl.validation.utils.MethodObj;
import org.xtext.example.mydsl.validation.utils.MethodValidate;
import org.xtext.example.mydsl.validation.utils.ModifiersValidate;
import org.xtext.example.mydsl.validation.utils.Variable;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  private final String CLASS = "class";
  
  private final String INTERFACE = "interface";
  
  private final String METHOD = "method";
  
  private final String VARIABLE = "variable";
  
  private final String CONSTRUCTOR = "constructor";
  
  public Classes allClasses = new Classes();
  
  @Check
  public void validaTypeDeclaration(final Type_declaration td) {
    Class_declaration _classDec = td.getClassDec();
    if ((_classDec instanceof Class_declaration)) {
      Class_declaration _classDec_1 = td.getClassDec();
      Class_declaration cd = ((Class_declaration) _classDec_1);
      String _className = cd.getClassName();
      boolean _findClass = this.allClasses.findClass(_className);
      boolean _not = (!_findClass);
      if (_not) {
        String _className_1 = cd.getClassName();
        EList<String> _modifiers = cd.getModifiers();
        ArrayList<String> _arrayList = new ArrayList<String>(_modifiers);
        boolean _contains = _arrayList.contains("abstract");
        this.allClasses.addClass(_className_1, _contains);
        String _className_2 = cd.getClassName();
        this.validaClass(cd, _className_2);
        EList<Field_declaration> _fieldsDeclaration = cd.getFieldsDeclaration();
        String _className_3 = cd.getClassName();
        this.validaFieldDeclaration(_fieldsDeclaration, this.METHOD, _className_3, true);
        EList<Field_declaration> _fieldsDeclaration_1 = cd.getFieldsDeclaration();
        String _className_4 = cd.getClassName();
        this.validaFieldDeclaration(_fieldsDeclaration_1, this.CONSTRUCTOR, _className_4, true);
        EList<Field_declaration> _fieldsDeclaration_2 = cd.getFieldsDeclaration();
        String _className_5 = cd.getClassName();
        this.validaFieldDeclaration(_fieldsDeclaration_2, this.VARIABLE, _className_5, true);
        String _classHerdada = cd.getClassHerdada();
        boolean _notEquals = (!Objects.equal(_classHerdada, null));
        if (_notEquals) {
          String _className_6 = cd.getClassName();
          EList<String> _modifiers_1 = cd.getModifiers();
          ArrayList<String> _arrayList_1 = new ArrayList<String>(_modifiers_1);
          boolean _contains_1 = _arrayList_1.contains("abstract");
          String _classHerdada_1 = cd.getClassHerdada();
          this.allClasses.addClass(_className_6, _contains_1, _classHerdada_1);
        }
        String _interfaceImplementada = cd.getInterfaceImplementada();
        boolean _notEquals_1 = (!Objects.equal(_interfaceImplementada, null));
        if (_notEquals_1) {
          List<String> aux = new ArrayList<String>();
          String _interfaceImplementada_1 = cd.getInterfaceImplementada();
          aux.add(_interfaceImplementada_1);
          EList<String> _interfacesImplementadas = cd.getInterfacesImplementadas();
          int _size = _interfacesImplementadas.size();
          boolean _greaterThan = (_size > 0);
          if (_greaterThan) {
            EList<String> _interfacesImplementadas_1 = cd.getInterfacesImplementadas();
            for (final String interfaces : _interfacesImplementadas_1) {
              aux.add(interfaces);
            }
          }
          String _className_7 = cd.getClassName();
          this.allClasses.setInterfacesImple(aux, _className_7);
        }
      }
    } else {
      Interface_declaration _interfaceDec = td.getInterfaceDec();
      Interface_declaration id = ((Interface_declaration) _interfaceDec);
      String _interfaceName = id.getInterfaceName();
      boolean _findInterface = this.allClasses.findInterface(_interfaceName);
      boolean _not_1 = (!_findInterface);
      if (_not_1) {
        String _interfaceName_1 = id.getInterfaceName();
        EList<String> _modifiers_2 = id.getModifiers();
        ArrayList<String> _arrayList_2 = new ArrayList<String>(_modifiers_2);
        boolean _contains_2 = _arrayList_2.contains("abstract");
        this.allClasses.addInter(_interfaceName_1, _contains_2);
        String _interfaceName_2 = id.getInterfaceName();
        this.validaInterface(id, _interfaceName_2);
        EList<Field_declaration> _fieldsDeclaration_3 = id.getFieldsDeclaration();
        String _interfaceName_3 = id.getInterfaceName();
        this.validaFieldDeclaration(_fieldsDeclaration_3, this.METHOD, _interfaceName_3, false);
        String _interfaceHerdada = id.getInterfaceHerdada();
        boolean _notEquals_2 = (!Objects.equal(_interfaceHerdada, null));
        if (_notEquals_2) {
          List<String> aux_1 = new ArrayList<String>();
          String _interfaceHerdada_1 = id.getInterfaceHerdada();
          aux_1.add(_interfaceHerdada_1);
          EList<String> _interfacesHerdadas = id.getInterfacesHerdadas();
          int _size_1 = _interfacesHerdadas.size();
          boolean _greaterThan_1 = (_size_1 > 0);
          if (_greaterThan_1) {
            EList<String> _interfacesHerdadas_1 = id.getInterfacesHerdadas();
            for (final String interfaces_1 : _interfacesHerdadas_1) {
              aux_1.add(interfaces_1);
            }
          }
          String _interfaceName_4 = id.getInterfaceName();
          this.allClasses.setInterfacesImpleToInt(aux_1, _interfaceName_4);
        }
      }
    }
  }
  
  @Check
  public void validExpression(final Expression exp) {
    ExpressionValidate ev = new ExpressionValidate();
    try {
      ev.validate(exp);
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        String _message = e.getMessage();
        this.error(_message, exp, MyDslPackage.Literals.EXPRESSION__LOGICAL_EXPRESSION);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public void validaMethods(final EList<Field_declaration> list, final String typeName, final boolean isClass) {
    MethodValidate mv = new MethodValidate();
    try {
      if (isClass) {
        Map<String, List<MethodObj>> _methodValidateAll = mv.methodValidateAll(list, typeName);
        this.allClasses.setMethods(_methodValidateAll, typeName);
      } else {
        Map<String, List<MethodObj>> _methodValidateAll_1 = mv.methodValidateAll(list, typeName);
        this.allClasses.setMethodsInter(_methodValidateAll_1, typeName);
      }
    } catch (final Throwable _t) {
      if (_t instanceof MyDslException) {
        final MyDslException e = (MyDslException)_t;
        List<Object> _nodeError = e.getNodeError();
        if ((_nodeError instanceof Variable_declaration)) {
          List<Object> _nodeError_1 = e.getNodeError();
          Variable_declaration vd = ((Variable_declaration) _nodeError_1);
          String _message = e.getMessage();
          this.error(_message, vd, MyDslPackage.Literals.VARIABLE_DECLARATION__MODIFIERS_VARIABLE);
        }
        MethodObj metAux = null;
        List<Object> _nodeError_2 = e.getNodeError();
        for (final Object methodsError : _nodeError_2) {
          {
            metAux = ((MethodObj) methodsError);
            String _message_1 = e.getMessage();
            String _string = metAux.toString();
            String _plus = (_message_1 + _string);
            String _plus_1 = (_plus + " in Type ");
            String _plus_2 = (_plus_1 + typeName);
            Method_declaration _md = metAux.getMd();
            this.error(_plus_2, _md, 
              MyDslPackage.Literals.METHOD_DECLARATION__NAME_METHOD);
          }
        }
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public boolean validaClass(final Class_declaration declaration, final String typeName) {
    boolean _xblockexpression = false;
    {
      try {
        EList<String> _modifiers = declaration.getModifiers();
        this.validaModifiers(_modifiers, this.CLASS, typeName);
      } catch (final Throwable _t) {
        if (_t instanceof Exception) {
          final Exception e = (Exception)_t;
          String _message = e.getMessage();
          this.error(_message, declaration, MyDslPackage.Literals.CLASS_DECLARATION__CLASS_NAME);
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      EList<String> interfaces = declaration.getInterfacesImplementadas();
      String _interfaceImplementada = declaration.getInterfaceImplementada();
      _xblockexpression = interfaces.add(_interfaceImplementada);
    }
    return _xblockexpression;
  }
  
  public void validaInterface(final Interface_declaration declaration, final String typeName) {
    try {
      EList<String> _modifiers = declaration.getModifiers();
      this.validaModifiers(_modifiers, this.INTERFACE, typeName);
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        String _message = e.getMessage();
        this.error(_message, declaration, MyDslPackage.Literals.INTERFACE_DECLARATION__INTERFACE_NAME);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public void validaFieldDeclaration(final EList<Field_declaration> declaration, final String fieldType, final String typeName, final boolean isClass) {
    boolean _equals = fieldType.equals(this.METHOD);
    if (_equals) {
      this.validaMethods(declaration, typeName, isClass);
    } else {
      boolean _equals_1 = fieldType.equals(this.CONSTRUCTOR);
      if (_equals_1) {
        this.validaContructor(declaration, typeName);
      } else {
        boolean _equals_2 = fieldType.equals(this.VARIABLE);
        if (_equals_2) {
          this.validaVariables(declaration, typeName);
        }
      }
    }
  }
  
  public void validaVariables(final EList<Field_declaration> list, final String typeName) {
    for (final Field_declaration fd : list) {
      Variable_declaration _variableDeclaration = fd.getVariableDeclaration();
      boolean _notEquals = (!Objects.equal(_variableDeclaration, null));
      if (_notEquals) {
        Variable variable = null;
        try {
          Variable_declaration _variableDeclaration_1 = fd.getVariableDeclaration();
          Variable _variable = new Variable(_variableDeclaration_1);
          variable = _variable;
        } catch (final Throwable _t) {
          if (_t instanceof Exception) {
            final Exception e = (Exception)_t;
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
        this.allClasses.setGlobalVar(variable, typeName);
        int _countNames = variable.getCountNames();
        boolean _greaterThan = (_countNames > 0);
        if (_greaterThan) {
          Variable_declaration _variableDeclaration_2 = fd.getVariableDeclaration();
          EList<Variable_declarator> _names = _variableDeclaration_2.getNames();
          for (final Variable_declarator varDecl : _names) {
            {
              String _nameVariable = varDecl.getNameVariable();
              variable.setName(_nameVariable);
              this.allClasses.setGlobalVar(variable, typeName);
            }
          }
        }
      }
    }
  }
  
  public void validaContructor(final EList<Field_declaration> list, final String typeName) {
    ContructorValidate cv = new ContructorValidate();
    try {
      List<ConstructorObj> _constructorValidateAll = cv.constructorValidateAll(list, typeName);
      this.allClasses.setConstructors(_constructorValidateAll, typeName);
    } catch (final Throwable _t) {
      if (_t instanceof MyDslException) {
        final MyDslException e = (MyDslException)_t;
        ConstructorObj constAux = null;
        List<Object> _nodeError = e.getNodeError();
        int _size = _nodeError.size();
        boolean _equals = (_size == 1);
        if (_equals) {
          List<Object> _nodeError_1 = e.getNodeError();
          Object _get = _nodeError_1.get(0);
          constAux = ((ConstructorObj) _get);
          String _message = e.getMessage();
          Constructor_declaration _md = constAux.getMd();
          this.error(_message, _md, MyDslPackage.Literals.CONSTRUCTOR_DECLARATION__NAME_CONSTRUCTOR);
        }
        List<Object> _nodeError_2 = e.getNodeError();
        for (final Object constError : _nodeError_2) {
          {
            constAux = ((ConstructorObj) constError);
            String _message_1 = e.getMessage();
            String _plus = (_message_1 + constAux);
            String _plus_1 = (_plus + " in Type ");
            String _plus_2 = (_plus_1 + typeName);
            Constructor_declaration _md_1 = constAux.getMd();
            this.error(_plus_2, _md_1, 
              MyDslPackage.Literals.CONSTRUCTOR_DECLARATION__NAME_CONSTRUCTOR);
          }
        }
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public void validaModifiers(final EList<String> list, final String type, final String typeName) throws Exception {
    ModifiersValidate modValidate = new ModifiersValidate();
    int size = list.size();
    String firstModifier = null;
    if ((size > 0)) {
      String _get = list.get(0);
      firstModifier = _get;
    }
    try {
      boolean _equals = type.equals(this.CLASS);
      if (_equals) {
        modValidate.classValidate(size, firstModifier, typeName, list);
      } else {
        boolean _equals_1 = type.equals(this.INTERFACE);
        if (_equals_1) {
          modValidate.interfaceValidate(size, firstModifier, typeName, list);
        }
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        throw e;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkMethodDeclaration(final Method_declaration md) {
    ModifiersValidate modValidate = new ModifiersValidate();
    EList<String> methodMods = md.getModifiersMethod();
    int size = methodMods.size();
    try {
      String _nameMethod = md.getNameMethod();
      Statement_block _statementMethod = md.getStatementMethod();
      boolean _notEquals = (!Objects.equal(_statementMethod, null));
      modValidate.methodValidate(size, _nameMethod, methodMods, "", 
        "", _notEquals);
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        String _message = e.getMessage();
        this.error(_message, md, MyDslPackage.Literals.METHOD_DECLARATION__NAME_METHOD);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public Object variableDeclaration(final Variable_declaration vd) {
    return null;
  }
  
  @Check
  public void validWhile(final While_Statement ws) {
    Expression exp = ws.getExpression();
    Expression_aux aux = exp.getAux();
    Logical_Expression_NR _logicalExpression = exp.getLogicalExpression();
    boolean _notEquals = (!Objects.equal(_logicalExpression, null));
    if (_notEquals) {
      while (((!Objects.equal(aux.getLogicalSign(), null)) || (!Objects.equal(exp.getLogicalExpression(), null)))) {
        {
          Expression _exp1 = aux.getExp1();
          exp = _exp1;
          Expression_aux _aux = aux.getAux();
          aux = _aux;
          String _logicalSign = aux.getLogicalSign();
          boolean _equals = Objects.equal(_logicalSign, null);
          if (_equals) {
            this.error("Operando not avalible", aux, MyDslPackage.Literals.EXPRESSION_AUX__LOGICAL_SIGN);
          }
          Logical_Expression_NR _logicalExpression_1 = exp.getLogicalExpression();
          boolean _notEquals_1 = (!Objects.equal(_logicalExpression_1, null));
          if (_notEquals_1) {
            this.error("type not avalible", exp, MyDslPackage.Literals.EXPRESSION__LOGICAL_EXPRESSION);
          }
        }
      }
    } else {
      this.error("parameter of While invalid", exp, MyDslPackage.Literals.EXPRESSION__LOGICAL_EXPRESSION);
    }
  }
}
