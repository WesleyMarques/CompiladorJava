/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation

import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check
import org.xtex.example.mydsl.exceptions.MyDslException
import org.xtext.example.mydsl.myDsl.Class_declaration
import org.xtext.example.mydsl.myDsl.Field_declaration
import org.xtext.example.mydsl.myDsl.Interface_declaration
import org.xtext.example.mydsl.myDsl.Method_declaration
import org.xtext.example.mydsl.myDsl.MyDslPackage
import org.xtext.example.mydsl.myDsl.Type_declaration
import org.xtext.example.mydsl.validation.utils.ConstructorObj
import org.xtext.example.mydsl.validation.utils.ContructorValidate
import org.xtext.example.mydsl.validation.utils.MethodObj
import org.xtext.example.mydsl.validation.utils.MethodValidate
import org.xtext.example.mydsl.validation.utils.ModifiersValidate

//import org.eclipse.xtext.validation.Check
/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {

	private final String CLASS = "class";
	private final String INTERFACE = "interface";
	private final String METHOD = "method";
	private final String CONSTRUCTOR = "constructor";
	
	public Map<String, String> typeInValidation = new HashMap<String, String>();
	public Map<String, List<String>> classeExtends = new HashMap<String, List<String>>();
	public Map<String, List<MethodObj>> methodNames = new HashMap<String, List<MethodObj>>();
	public List<ConstructorObj> constructors = new ArrayList<ConstructorObj>();

	@Check
	def validaTypeDeclaration(Type_declaration td) {
		if (td.classDec instanceof Class_declaration) {
			var Class_declaration cd = td.classDec as Class_declaration;
			typeInValidation.put("tipo", "class");
			typeInValidation.put("name", cd.className);
			typeInValidation.put("abstract", new ArrayList<String>(cd.modifiers).contains("abstract") + "");
			validaClass(cd);
			validaFieldDeclaration(cd.fieldsDeclaration, METHOD);
			validaFieldDeclaration(cd.fieldsDeclaration, CONSTRUCTOR);

		} else {
			var Interface_declaration id = td.interfaceDec as Interface_declaration;
			typeInValidation.put("tipo", "interface");
			typeInValidation.put("name", id.interfaceName);
			typeInValidation.put("abstract", new ArrayList<String>(id.modifiers).contains("abstract") + "");
			validaInterface(id);
			validaFieldDeclaration(id.fieldsDeclaration, METHOD);
		}

	}

	def validaMethods(EList<Field_declaration> list) {
		var MethodValidate mv = new MethodValidate();
		try {
			methodNames = mv.methodValidateAll(list, typeInValidation.get("name"));
		} catch (MyDslException e) {
			var MethodObj metAux;
			for (Object methodsError : e.nodeError) {
				metAux = methodsError as MethodObj;
				error(e.message + (metAux.toString) + " in Type " + typeInValidation.get("name"), metAux.md,
					MyDslPackage.Literals.METHOD_DECLARATION__NAME_METHOD);
			}
		}

	}

	def validaClass(Class_declaration declaration) {
		try {
			validaModifiers(declaration.modifiers, CLASS);
		} catch (Exception e) {
			error(e.message, declaration, MyDslPackage.Literals.CLASS_DECLARATION__CLASS_NAME);
		}

		var EList<String> interfaces = declaration.interfacesImplementadas;
		interfaces.add(declaration.interfaceImplementada);
	}

	def validaInterface(Interface_declaration declaration) {
		try {
			validaModifiers(declaration.modifiers, INTERFACE);
		} catch (Exception e) {
			error(e.message, declaration, MyDslPackage.Literals.INTERFACE_DECLARATION__INTERFACE_NAME);

		}

	}

	def validaFieldDeclaration(EList<Field_declaration> declaration, String fieldType) {
		if (fieldType.equals(METHOD)) {
			validaMethods(declaration);
		} else if (fieldType.equals(CONSTRUCTOR)) {
			validaContructor(declaration);
		}

	}
	
	def validaContructor(EList<Field_declaration> list) {
		var ContructorValidate cv = new ContructorValidate();
		try{
			this.constructors = cv.constructorValidateAll(list,typeInValidation.get("name"));
		}catch(MyDslException e){
			var ConstructorObj constAux;
			if(e.nodeError.size() == 1){
				constAux = e.nodeError.get(0) as ConstructorObj;
				error(e.message, constAux.md,
					MyDslPackage.Literals.CONSTRUCTOR_DECLARATION__NAME_CONSTRUCTOR);
			}
			
			for (Object constError : e.nodeError) {
				constAux = constError as ConstructorObj;
				error(e.message+ (constAux	) + " in Type " + typeInValidation.get("name"), constAux.md,
					MyDslPackage.Literals.CONSTRUCTOR_DECLARATION__NAME_CONSTRUCTOR);
			}
		}
		
	}

	def validaModifiers(EList<String> list, String type) throws Exception{
		var ModifiersValidate modValidate = new ModifiersValidate();
		var String typeName = typeInValidation.get("name");
		var int size = list.size();
		var String firstModifier;
		if (size > 0) {
			firstModifier = list.get(0);
		}
		try {
			if (type.equals(CLASS)) {
				modValidate.classValidate(size, firstModifier, typeName, list);
			} else if (type.equals(INTERFACE)) {
				modValidate.interfaceValidate(size, firstModifier, typeName, list);
			}

		} catch (Exception e) {
			throw e;
		}

	}

	@Check
	def checkMethodDeclaration(Method_declaration md) {

		var ModifiersValidate modValidate = new ModifiersValidate();
		var EList<String> methodMods = md.modifiersMethod;
		var int size = methodMods.size();
		try {
			modValidate.methodValidate(size, md.nameMethod, methodMods, typeInValidation.get("name"),
				typeInValidation.get("abstract"), md.statementMethod != null);
		} catch (Exception e) {
			error(e.message, md, MyDslPackage.Literals.METHOD_DECLARATION__NAME_METHOD);
		}

	}

}
