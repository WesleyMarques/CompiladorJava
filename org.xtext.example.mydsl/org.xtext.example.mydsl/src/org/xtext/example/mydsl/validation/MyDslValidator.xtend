/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation

import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.myDsl.Class_declaration
import org.xtext.example.mydsl.myDsl.Field_declaration
import org.xtext.example.mydsl.myDsl.Interface_declaration
import org.xtext.example.mydsl.myDsl.Method_declaration
import org.xtext.example.mydsl.myDsl.Type_declaration
import org.xtext.example.mydsl.myDsl.MyDslPackage

//import org.eclipse.xtext.validation.Check
/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}


	
	public Map<String, List<String>> classeExtends = new HashMap<String, List<String>>();
	

	@Check
	def validaTypeDeclaration(Type_declaration td) {
		if (td.classDec instanceof Class_declaration) {
			var Class_declaration cd = td.classDec as Class_declaration;
			validaClass(cd);

		} else {
			var Interface_declaration id = td.interfaceDec as Interface_declaration;
			validaInterface(id);
		}
	}
	
	def validaInterface(Interface_declaration declaration) {
		validaModifiers(declaration.modifiers);
		for(Field_declaration field:declaration.fieldsDeclaration){
			validaFieldDeclaration(field);			
		}
		
	}
	
	def validaFieldDeclaration(Field_declaration declaration) {
		
	}
	
	def validaModifiers(EList<String> list) {
		
	}
	
	def validaClass(Class_declaration declaration) {
		validaModifiers(declaration.modifiers);
		var EList<String> interfaces = declaration.interfacesImplementadas;
		interfaces.add(declaration.interfaceImplementada);
		for(String interfaceName:interfaces){
			validaHerancaInterface(declaration, interfaceName);
		}
		validaHerancaClass(declaration.classHerdada);
	}
	
	def validaHerancaClass(String string) {
		
	}
	
	def validaHerancaInterface(Class_declaration declaration, String string) {
		
	}
	
	@Check
	def checkMethodDeclaration(Method_declaration md){
		var EList<String> methodMods = md.modifiersMethod;
		var int a = 0;
		for(String mod:methodMods){
			if(a == 0 && mod.equals("public")){
				error("Classe name error",md, MyDslPackage.Literals.METHOD_DECLARATION__NAME_METHOD);
				
			}
		}
	}

	
}
