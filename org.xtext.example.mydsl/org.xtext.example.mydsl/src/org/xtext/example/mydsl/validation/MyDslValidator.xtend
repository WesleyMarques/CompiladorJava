/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation

import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.myDsl.Class_declaration
import org.xtext.example.mydsl.myDsl.Field_declaration
import org.xtext.example.mydsl.myDsl.Interface_declaration
import org.xtext.example.mydsl.myDsl.Method_declaration
import org.xtext.example.mydsl.myDsl.MyDslPackage
import org.xtext.example.mydsl.myDsl.Type_declaration
import java.util.ArrayList

//import org.eclipse.xtext.validation.Check
/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MyDslValidator extends AbstractMyDslValidator {

	private final String CLASS = "class";
	private final String INTERFACE = "interface";

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	public Map<String, String> typeInValidation = new HashMap<String, String>();
	public Map<String, List<String>> classeExtends = new HashMap<String, List<String>>();
	public Map<String, List<String>> methodNames = new HashMap<String, List<String>>();

	@Check
	def validaTypeDeclaration(Type_declaration td) {
		if (td.classDec instanceof Class_declaration) {
			var Class_declaration cd = td.classDec as Class_declaration;
			typeInValidation.put("tipo", "class");
			typeInValidation.put("name", cd.className);
			typeInValidation.put("abstract", new ArrayList<String>(cd.modifiers).contains("abstract") + "");

			validaClass(cd);

		} else {
			var Interface_declaration id = td.interfaceDec as Interface_declaration;
			typeInValidation.put("tipo", "interface");
			typeInValidation.put("name", id.interfaceName);
			typeInValidation.put("abstract", new ArrayList<String>(id.modifiers).contains("abstract") + "");
			validaInterface(id);
		}
	}

	def validaClass(Class_declaration declaration) {
		try {
			validaModifiers(declaration.modifiers, CLASS);
		} catch (Exception e) {
			error(e.message, declaration, MyDslPackage.Literals.CLASS_DECLARATION__CLASS_NAME);
		}
		var EList<String> interfaces = declaration.interfacesImplementadas;
		interfaces.add(declaration.interfaceImplementada);
		for (String interfaceName : interfaces) {
			validaHerancaInterface(declaration, interfaceName);
		}
		validaHerancaClass(declaration.classHerdada);
	}

	def validaInterface(Interface_declaration declaration) {
		try {
			validaModifiers(declaration.modifiers, INTERFACE);
		} catch (Exception e) {
			error(e.message, declaration, MyDslPackage.Literals.INTERFACE_DECLARATION__INTERFACE_NAME);
		}
		for (Field_declaration field : declaration.fieldsDeclaration) {
			validaFieldDeclaration(field);
		}

	}

	def validaFieldDeclaration(Field_declaration declaration) {
	}

	def validaModifiers(EList<String> list, String type) throws Exception{
		var ModifiersValidate modValidate = new ModifiersValidate();
		var String typeName = typeInValidation.get("name");
		var int size = list.size();
		var String firstModifier;
		if (size > 0) {
			firstModifier = list.get(0);
		}
		try {
			if (type.equals(CLASS)) {
				modValidate.classValidate(size, firstModifier, typeName, list);
			} else if (type.equals(INTERFACE)) {
				modValidate.interfaceValidate(size, firstModifier, typeName, list);
			}

		} catch (Exception e) {
			throw e;
		}

	}

	def validaHerancaClass(String string) {
	}

	def validaHerancaInterface(
		Class_declaration declaration,
		String string
	) {
	}

	@Check
	def checkMethodDeclaration(Method_declaration md) {

		var ModifiersValidate modValidate = new ModifiersValidate();
		var EList<String> methodMods = md.modifiersMethod;
		var int size = methodMods.size();
		try {
			modValidate.methodValidate(size, md.nameMethod, methodMods, typeInValidation.get("name"),
				typeInValidation.get("abstract"), md.statementMethod != null);
		} catch (Exception e) {
			error(e.message, md, MyDslPackage.Literals.METHOD_DECLARATION__NAME_METHOD);
		}

	}

}
